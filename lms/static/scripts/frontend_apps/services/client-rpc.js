import { TinyEmitter } from 'tiny-emitter';

import { Server, call as rpcCall } from '../../postmessage_json_rpc';
import { apiCall } from '../utils/api';
import { JWT } from '../utils/jwt';

/**
 * @typedef User
 * @prop {string} displayName
 * @prop {string} userid
 */

/**
 * @typedef ServiceConfig
 * @prop {string} grantToken
 */

/**
 * The subset of the Hypothesis client configuration that `ClientRPC` directly references.
 *
 * The backend will add other properties which are intentionally not included here,
 * even as an index signature. This other configuration is simply forwarded to
 * the client but not touched by `ClientRPC`.
 *
 * See https://h.readthedocs.io/projects/client/en/latest/publishers/config/.
 *
 * @typedef ClientConfig
 * @prop {[ServiceConfig]} services - Annotation configuration for the client.
 *   In the LMS context this will always consist of exactly one entry.
 * @prop {object} [reportActivity] -- TODO
 */

/**
 * Service for communicating with the Hypothesis client.
 *
 * This service handles:
 *
 *  - Waiting for the Hypothesis client to request its configuration and then
 *    returning the configuration data generated by the LMS backend to the
 *    client.
 *  - Updating the Hypothesis client configuration in response to input
 *    in the LMS frontend, such as changing the focused user in grading mode.
 */
export class ClientRPC extends TinyEmitter {
  /**
   * Setup the RPC server used to communicate with the Hypothesis client.
   *
   * @param {object} options
   *   @param {string[]} options.allowedOrigins -
   *     Origins that are allowed to request client configuration
   *   @param {string} options.authToken -
   *     Auth token used in LMS backend API calls to refresh the grant token
   *     in the `clientConfig` if it has expired
   *   @param {ClientConfig} options.clientConfig -
   *     Configuration for the Hypothesis client. Whatever is provided here is
   *     passed directly to the client via `window.postMessage` when it requests
   *     configuration. It should be a subset of the config options specified at
   *     https://h.readthedocs.io/projects/client/en/latest/publishers/config/.
   */
  constructor({ allowedOrigins, authToken, clientConfig }) {
    super();
    this._server = new Server(allowedOrigins);

    // A conservative estimate of when the grant token was issued.
    // When this is older than the true value, the frontend will just consider it
    // to "expire" earlier than it really does.
    const issuedAt = Date.now() - 30 * 1000;
    let grantToken = new JWT(clientConfig.services[0].grantToken, issuedAt);

    // Handle the requests for configuration from the Hypothesis client.
    this._server.register('requestConfig', async () => {
      if (grantToken.hasExpired()) {
        const issuedAt = Date.now();
        try {
          const response = await apiCall({
            authToken,
            path: '/api/grant_token',
          });
          grantToken = new JWT(response.grant_token, issuedAt);
        } catch (err) {
          throw new Error(
            'Unable to fetch Hypothesis login. Please reload the assignment.'
          );
        }
      }

      clientConfig.services[0].grantToken = grantToken.value();
      clientConfig.reportActivity = {
        method: 'reportActivity',
        events: ['create', 'update'],
      };
      return clientConfig;
    });

    this._server.register('reportActivity', (event, data) => {
      this.emit('annotationActivity', event, data);
      return true;
    });

    const groups = new Promise(resolve => {
      this._resolveGroups = resolve;
    });

    // Handle the request for the list of groups to display from the Hypothesis
    // client.
    //
    // Determining the list of groups to display may take time on the backend
    // due to potentially slow calls to the external LMS to determine which course
    // section the user is in. Therefore we separate the request for the rest of
    // the Hypothesis client configuration from the request for the groups to
    // show. This enables the client to do most of its startup before the
    // group list is available.
    this._server.register('requestGroups', () => groups);
  }

  /**
   * Set which groups are available to select in the client.
   *
   * This method should be called exactly once during the LTI launch and calling
   * it a second time will have no effect.
   *
   * @param {string[]} groups
   */
  setGroups(groups) {
    this._resolveGroups(groups);
  }

  /**
   * Set which user is focused in the client or none if `user` is `null`.
   *
   * This may be called any number of times.
   *
   * @param {User|null} user
   * @param {string[]|null} groups - Array of `groupid`s representing the
   *  focused user's groups
   */
  async setFocusedUser(user, groups) {
    const sidebar = await this._server.sidebarWindow;
    rpcCall(sidebar.frame, sidebar.origin, 'changeFocusModeUser', [
      {
        // Passing `undefined` as the `username` disables focus mode in the client.
        //
        // TODO: The `username` property is deprecated in the client and should be
        // changed to `userid` once the client no longer references `username`.
        username: user ? user.userid : undefined,
        displayName: user ? user.displayName : undefined,
        groups: groups ?? undefined,
      },
    ]);
  }
}
