import { Server, call as rpcCall } from '../../postmessage_json_rpc';
import { apiCall } from '../utils/api';

/**
 * @typedef User
 * @prop {string} displayName
 * @prop {string} userid
 */

/**
 * @typedef ServiceConfig
 * @prop {string} grantToken
 */

/**
 * The subset of the Hypothesis client configuration that `ClientRpc` references.
 *
 * The backend will set other configuration which is just forwarded to the client
 * and not touched by `ClientRpc`.
 *
 * See https://h.readthedocs.io/projects/client/en/latest/publishers/config/.
 *
 * @typedef ClientConfig
 * @prop {[ServiceConfig]} services
 */

/**
 * Return the time at which a JWT token expires.
 *
 * @param {string} jwtToken
 * @return {number} - JWT expiry timestamp in milliseconds. This can be compared
 *   with `Date.now()`.
 */
function jwtExpiry(jwtToken) {
  const [, payloadBase64] = jwtToken.split('.');
  const payload = JSON.parse(atob(payloadBase64));
  if (typeof payload.exp !== 'number') {
    throw new Error('JWT token does not have a valid expiry ("exp") field');
  }
  // Convert from seconds to milliseconds to match JS timestamp conventions.
  return payload.exp * 1000;
}

/**
 * Service for communicating with the Hypothesis client.
 *
 * This service handles:
 *
 *  - Waiting for the Hypothesis client to request its configuration and then
 *    returning the configuration data generated by the LMS backend to the
 *    client.
 *  - Updating the Hypothesis client configuration in response to input
 *    in the LMS frontend, such as changing the focused user in grading mode.
 */
export class ClientRpc {
  /**
   * Setup the RPC server used to communicate with the Hypothesis client.
   *
   * @param {Object} options
   *   @param {string[]} options.allowedOrigins -
   *     Origins that are allowed to request client configuration
   *   @param {string} options.authToken -
   *     Auth token used in LMS backend API calls to refresh the grant token
   *     in the `clientConfig` if it has expired
   *   @param {ClientConfig} options.clientConfig -
   *     Configuration for the Hypothesis client. Whatever is provided here is
   *     passed directly to the client via `window.postMessage` when it requests
   *     configuration. It should be a subset of the config options specified at
   *     https://h.readthedocs.io/projects/client/en/latest/publishers/config/.
   */
  constructor({ allowedOrigins, authToken, clientConfig }) {
    this._server = new Server(allowedOrigins);

    // Handle the requests for configuration from the Hypothesis client.
    this._server.register('requestConfig', async () => {
      // Refresh the grant token used by the client to access the H API, if
      // it expired.
      const grantToken = clientConfig.services[0].grantToken;
      const now = Date.now();
      if (now > jwtExpiry(grantToken)) {
        const response = await apiCall({
          authToken,
          path: '/api/grant_token',
        });
        if (typeof response.grant_token !== 'string') {
          throw new Error('Invalid grant_token response');
        }
        clientConfig.services[0].grantToken = response.grant_token;
      }

      return clientConfig;
    });

    const groups = new Promise(resolve => {
      this._resolveGroups = resolve;
    });

    // Handle the request for the list of groups to display from the Hypothesis
    // client.
    //
    // Determining the list of groups to display may take time on the backend
    // due to potentially slow calls to the external LMS to determine which course
    // section the user is in. Therefore we separate the request for the rest of
    // the Hypothesis client configuration from the request for the groups to
    // show. This enables the client to do most of its startup before the
    // group list is available.
    this._server.register('requestGroups', () => groups);
  }

  /**
   * Set which groups are available to select in the client.
   *
   * This method should be called exactly once during the LTI launch and calling
   * it a second time will have no effect.
   *
   * @param {string[]} groups
   */
  setGroups(groups) {
    this._resolveGroups(groups);
  }

  /**
   * Set which user is focused in the client or none if `user` is `null`.
   *
   * This may be called any number of times.
   *
   * @param {User|null} user
   */
  async setFocusedUser(user) {
    const sidebar = await this._server.sidebarWindow;
    rpcCall(sidebar.frame, sidebar.origin, 'changeFocusModeUser', [
      {
        // Passing `undefined` as the `username` disables focus mode in the client.
        //
        // TODO: The `username` property is deprecated in the client and should be
        // changed to `userid` once the client no longer references `username`.
        username: user ? user.userid : undefined,
        displayName: user ? user.displayName : undefined,
      },
    ]);
  }
}
