import { TinyEmitter } from 'tiny-emitter';

import { Server, call as rpcCall } from '../../postmessage_json_rpc';
import { apiCall } from '../utils/api';
import { JWT } from '../utils/jwt';

/**
 * @typedef User
 * @prop {string} displayName
 * @prop {string} userid
 */

/**
 * @typedef {'create'|'update'|'flag'|'delete'} AnnotationEventType
 *
 * @typedef AnnotationEventData
 * @prop {string} date
 * @prop {object} annotation
 *  @prop {string} annotation.id
 *  @prop {boolean} annotation.isShared
 */

/**
 * @typedef {import('../config').ClientConfig} ClientConfig
 */

/**
 * Content provider logo details.
 *
 * @typedef ContentInfoLogo
 * @prop {string} logo
 * @prop {string} title
 * @prop {string} link
 */

/**
 * Metadata for the current document, for display in the content info banner.
 *
 * @typedef ContentInfoItem
 * @prop {string} title - Title of the current article, chapter etc.
 * @prop {string} containerTitle - Title of the journal issue, book etc. which
 *   contains the current work
 */

/**
 * Links related to the current document, for display in the content info banner.
 *
 * @typedef ContentInfoLinks
 * @prop {string} [previousItem] - Previous item in the book, journal etc.
 * @prop {string} [nextItem] - Next item in the book, journal etc.
 */

/**
 * Configuration for content information banner in client.
 *
 * This and other `ContentInfo*` types are copied from the hypothesis/client repo.
 *
 * @typedef {object} ContentInfoConfig
 * @prop {ContentInfoLogo} logo - Logo of the content provider
 * @prop {ContentInfoItem} item
 * @prop {ContentInfoLinks} links
 */

/**
 * Service for communicating with the Hypothesis client.
 *
 * This service handles:
 *
 *  - Waiting for the Hypothesis client to request its configuration and then
 *    returning the configuration data generated by the LMS backend to the
 *    client.
 *  - Updating the Hypothesis client configuration in response to input
 *    in the LMS frontend, such as changing the focused user in grading mode.
 */
export class ClientRPC extends TinyEmitter {
  /**
   * Setup the RPC server used to communicate with the Hypothesis client.
   *
   * @param {object} options
   *   @param {string[]} options.allowedOrigins -
   *     Origins that are allowed to request client configuration
   *   @param {string} options.authToken -
   *     Auth token used in LMS backend API calls to refresh the grant token
   *     in the `clientConfig` if it has expired
   *   @param {ClientConfig} options.clientConfig -
   *     Configuration for the Hypothesis client. Whatever is provided here is
   *     passed directly to the client via `window.postMessage` when it requests
   *     configuration. It should be a subset of the config options specified at
   *     https://h.readthedocs.io/projects/client/en/latest/publishers/config/.
   */
  constructor({ allowedOrigins, authToken, clientConfig }) {
    super();
    this._server = new Server(allowedOrigins);

    // A conservative estimate of when the grant token was issued.
    // When this is older than the true value, the frontend will just consider it
    // to "expire" earlier than it really does.
    const issuedAt = Date.now() - 30 * 1000;
    let grantToken = new JWT(clientConfig.services[0].grantToken, issuedAt);

    // Handle the requests for configuration from the Hypothesis client.
    this._server.register('requestConfig', async () => {
      if (grantToken.hasExpired()) {
        const issuedAt = Date.now();
        try {
          const response = await apiCall({
            authToken,
            path: '/api/grant_token',
          });
          grantToken = new JWT(response.grant_token, issuedAt);
        } catch (err) {
          throw new Error(
            'Unable to fetch Hypothesis login. Please reload the assignment.'
          );
        }
      }

      clientConfig.services[0].grantToken = grantToken.value();
      return clientConfig;
    });

    this._server.register(
      'reportActivity',
      /**
       * @param {AnnotationEventType} eventType
       * @param {AnnotationEventData} data
       */
      (eventType, data) => {
        this.emit('annotationActivity', eventType, data);
      }
    );

    const groups = new Promise(resolve => {
      this._resolveGroups = resolve;
    });

    // Handle the request for the list of groups to display from the Hypothesis
    // client.
    //
    // Determining the list of groups to display may take time on the backend
    // due to potentially slow calls to the external LMS to determine which course
    // section the user is in. Therefore we separate the request for the rest of
    // the Hypothesis client configuration from the request for the groups to
    // show. This enables the client to do most of its startup before the
    // group list is available.
    this._server.register('requestGroups', () => groups);
  }

  /**
   * Set which groups are available to select in the client.
   *
   * This method should be called exactly once during the LTI launch and calling
   * it a second time will have no effect.
   *
   * @param {string[]} groups
   */
  setGroups(groups) {
    this._resolveGroups(groups);
  }

  /**
   * Set which user is focused in the client or none if `user` is `null`.
   *
   * This may be called any number of times.
   *
   * @param {User|null} user
   * @param {string[]|null} groups - Array of `groupid`s representing the
   *  focused user's groups
   */
  async setFocusedUser(user, groups) {
    await this._callClient('changeFocusModeUser', {
      // Passing `undefined` as the `username` disables focus mode in the client.
      //
      // TODO: The `username` property is deprecated in the client and should be
      // changed to `userid` once the client no longer references `username`.
      username: user ? user.userid : undefined,
      displayName: user ? user.displayName : undefined,
      groups: groups ?? undefined,
    });
  }

  /**
   * Instruct the client to show a content information banner.
   *
   * @param {ContentInfoConfig} info - Data to show in the banner
   */
  async showContentInfo(info) {
    await this._callClient('showContentInfo', info);
  }

  /**
   * Make an RPC request to the client.
   *
   * @param {string} method
   * @param {unknown[]} args
   */
  async _callClient(method, ...args) {
    const sidebar = await this._server.sidebarWindow;
    return rpcCall(sidebar.frame, sidebar.origin, method, args);
  }
}
