from dataclasses import asdict, dataclass
from datetime import timedelta
from typing import Callable
from urllib.parse import parse_qs, urlparse

from lms.services.exceptions import ExpiredJWTError, InvalidJWTError
from lms.services.jwt import JWTService
from lms.services.user_preferences import UserPreferencesService


class UnrecognisedURLError(Exception):
    pass


class InvalidTokenError(Exception):
    pass


@dataclass(frozen=True)
class EmailPrefs:  # pylint:disable=too-many-instance-attributes
    DAYS = ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]

    h_userid: str
    mon: bool = True
    tue: bool = True
    wed: bool = True
    thu: bool = True
    fri: bool = True
    sat: bool = True
    sun: bool = True

    def days(self) -> dict:
        return {key: value for key, value in asdict(self).items() if key in self.DAYS}


@dataclass(frozen=True)
class TokenPayload:
    """Payload for the token in an email preferences or unsubscribe link."""

    h_userid: str
    tag: str


class EmailPreferencesService:
    def __init__(  # noqa: PLR0913
        self,
        db,
        secret: str,
        route_url: Callable,
        jwt_service: JWTService,
        user_preferences_service: UserPreferencesService,
    ):
        self._db = db
        self._secret = secret
        self._route_url = route_url
        self._jwt_service = jwt_service
        self._user_preferences_service = user_preferences_service

    def unsubscribe_url(self, h_userid, tag):
        """Return an email unsubscribe URL for the given h_userid.

        The URL will contain a scoped and time-limited authentication token for
        the given h_userid in a query param.
        """
        return self._url("unsubscribe", h_userid, tag)

    def preferences_url(self, h_userid, tag):
        """Return a URL for the email preferences page for the given h_userid.

        The URL will contain a scoped and time-limited authentication token for
        the given h_userid in a query param.
        """
        return self._url("preferences", h_userid, tag)

    def _url(self, route, h_userid, tag):
        return self._route_url(
            f"email.{route}",
            _query={"token": self._encode_token(TokenPayload(h_userid, tag))},
        )

    def unsubscribe(self, h_userid):
        """Unsubscribe `h_userid` from emails of type `tag`."""
        self.set_preferences(
            EmailPrefs(h_userid, **{day: False for day in EmailPrefs.DAYS})
        )

    def decode(self, url: str) -> TokenPayload:
        """Return the decoded token from the given URL.

        `url` should be a URL generated by one of this service's methods above.

        :raises UnrecognisedURLError: if the given URL does not appear to be
            one generated by this service
        :raises InvalidTokenError: if the URL's authentication token is invalid
            or has expired
        """
        try:
            token = parse_qs(urlparse(url).query)["token"][0]
        except (KeyError, ValueError) as err:
            raise UnrecognisedURLError() from err

        try:
            return TokenPayload(
                **self._jwt_service.decode_with_secret(token, self._secret)
            )
        except (ExpiredJWTError, InvalidJWTError) as err:
            raise InvalidTokenError() from err

    KEY_PREFIX = "instructor_email_digests.days."

    def get_preferences(self, h_userid) -> EmailPrefs:
        """Return h_userid's email preferences."""
        user_preferences = self._user_preferences_service.get(h_userid)

        return EmailPrefs(
            h_userid=user_preferences.h_userid,
            **{
                key[len(self.KEY_PREFIX) :]: value
                for key, value in user_preferences.preferences.items()
                if key.startswith(self.KEY_PREFIX)
            },
        )

    def set_preferences(self, prefs: EmailPrefs) -> None:
        """Create or update h_userid's email preferences."""
        self._user_preferences_service.set(
            prefs.h_userid,
            {self.KEY_PREFIX + key: value for key, value in prefs.days().items()},
        )

    def _encode_token(self, payload: TokenPayload):
        return self._jwt_service.encode_with_secret(
            asdict(payload), self._secret, lifetime=timedelta(days=30)
        )


def factory(_context, request):
    return EmailPreferencesService(
        request.db,
        secret=request.registry.settings["jwt_secret"],
        route_url=request.route_url,
        jwt_service=request.find_service(iface=JWTService),
        user_preferences_service=request.find_service(UserPreferencesService),
    )
